---
layout: post
title: "leetcode"
subtitle: "每日一道"
date: 2025-04-15 23:10:00
author: "NiuHuLu"
catalog: false
published: true
header-style: text
tags:
  - leetcode
---
# 思考
- 分析题目
- 选择合适的方法
- 实现它



# 树
## 树的遍历
### dfs遍历
### 迭代（显示栈）
### bfs（队列，也是迭代法的一种）

```
例子1：
      1
     / \
    2   3
   / \
  4   5
前序：中左右
  根节点 ---->左子树---->右子树
  [1, 2, 4, 5, 3]
中序：左中右
  左子树 ---->根节点 ----> 右子树
  [4, 2, 5, 1, 3]
后续：左右中
  左子树 ----> 右子树 ----> 根节点
  [4, 5, 2, 3, 1]

例子2：
      2
     / \
    3   4
   / \
  5   6
  前序：中左右
  根节点 ---->左子树---->右子树
  [2,3，5,6,4]
中序：左中右
  左子树 ---->根节点 ----> 右子树
  [5,3,6,2,4]
后续：左右中
  左子树 ----> 右子树 ----> 根节点
  [5,6,3,4,2]


例子3：
      2
     / \
    4   3
       / \
      6   5
  前序：中左右
  根节点 ---->左子树---->右子树
  [2,4,3,6,5]
中序：左中右
  左子树 ---->根节点 ----> 右子树
  [4,2,6,3,5]
后续：左右中
  左子树 ----> 右子树 ----> 根节点
  [4,6,5,3,2]

```

### 树的节点的变化
```
你有一本书 book，你在**每一页上用笔写了点备注（比如：next page: 45）**，虽然书的内容增加了标记，但这本书 还是同一本，book 没有被换掉，只是内部内容加了东西。

例子1
root ─────▶ [Node(1)]
              │
              ├── left ───▶ [Node(2)]
              │                 └── next: None
              ├── right ──▶ [Node(3)]
              │                 └── next: None
              └── next: None



root ─────▶ [Node(1)]
              │
              ├── left ───▶ [Node(2)] ─── next ───▶ [Node(3)]
              ├── right ──▶ [Node(3)]
              └── next: None

例子2：
root ─────▶ [Node(1)]
              ├── left ───▶ [Node(2)]
              │               ├── left ───▶ [Node(4)]   next: None
              │               └── right ──▶ [Node(5)]   next: None
              │               next: None
              └── right ──▶ [Node(3)]
                              ├── left ───▶ [Node(6)]   next: None
                              └── right ──▶ [Node(7)]   next: None
                              next: None

root ─────▶ [Node(1)]  next: None
              ├── left ───▶ [Node(2)] ─── next ───▶ [Node(3)] ─── next: None
              │               ├── left ───▶ [Node(4)] ───▶ [Node(5)] ───▶ [Node(6)] ───▶ [Node(7)] ───▶ None
              │               └── right ──▶ [Node(5)]
              └── right ──▶ [Node(3)]
                              ├── left ───▶ [Node(6)]
                              └── right ──▶ [Node(7)]


```

### 层序遍历中for循环的理解
备注：层序遍历不一定需要for，只有当需要有层级关系的时候才需要for。也就是说返回一维数组的时候是不需要for，有层级关系的时候，返回的是二维数组

#### 普通bfs
```
        1
       / \
      2   3
     / \   \
    4   5   6

    普通 BFS 的步骤如下：

初始化队列：[1]

进入 while queue 循环：
当前队列长度 = 1，for _ in range(1) 执行 1 次：
弹出 1，处理它，并把它的子节点 2 和 3 加入队列。
现在队列是 [2, 3]。
当前队列长度 = 2，for _ in range(2) 执行 2 次：
弹出 2，处理它，并把它的子节点 4 和 5 加入队列。
弹出 3，处理它，并把它的子节点 6 加入队列。
现在队列是 [4, 5, 6]。
当前队列长度 = 3，for _ in range(3) 执行 3 次：
弹出 4，它没有子节点，不加入队列。
弹出 5，它没有子节点，不加入队列。
弹出 6，它没有子节点，不加入队列。
现在队列为空，退出循环。
关键点：
每次 for 循环的次数由当前层的节点数决定（len(queue)）。
每次只处理一个节点，并按固定顺序（左→右）入队子节点。
```

#### 合并二叉树中的for理解
```
while deque:
    for i in range(len(deque)):  # ❌ 问题在这里！
        node1 = deque.pop(0)
        node2 = deque.pop(0)
        # ... 处理 node1 和 node2 ...

树 1：        树 2：
    1            10
   / \          /  \
  2   3        20  30

  初始队列：[1, 10]（root1 和 root2）

错误流程：
while deque 开始：
len(deque) = 2，for i in range(2) 执行 2 次：
第一次迭代 (i=0)：
弹出 node1=1 和 node2=10。
合并它们的值：1.val = 1 + 10 = 11。
检查它们的左子节点：
1.left = 2 和 10.left = 20 都存在，所以 [2, 20] 入队。
检查它们的右子节点：
1.right = 3 和 10.right = 30 都存在，所以 [3, 30] 入队。
现在队列是 [2, 20, 3, 30]。
第二次迭代 (i=1)：
弹出 node1=2 和 node2=20。
合并它们的值：2.val = 2 + 20 = 22。
检查它们的左子节点：
2.left 和 20.left 都不存在，不操作。
检查它们的右子节点：
2.right 和 20.right 都不存在，不操作。
现在队列是 [3, 30]。
for 循环结束（因为 i 已经跑到 1 了）。
但队列里还有 [3, 30] 没处理！因为 for 循环的次数是基于初始 len(deque)=2 决定的，但队列长度在循环中动态变化了。
问题总结：
for i in range(len(deque)) 的 len(deque) 只在循环开始时计算一次，但你在循环中修改了队列长度（弹出 2 个，可能又加入 2~4 个）。
导致部分节点对未被处理。
```

### 二叉树的最近公共祖先和二叉搜索树的最近公共祖先